# Story 4.3: 노트 내용 기반 자동 태그 생성

## Status
Ready for Review

## Story
**As a** 로그인한 사용자,
**I want** 노트 내용을 기반으로 최대 6개의 관련 태그를 자동으로 생성하고,
**so that** 노트를 효율적으로 분류하고 검색할 수 있다

## Acceptance Criteria
1. 노트 저장 시 자동으로 태그 생성을 트리거할 수 있어야 함
2. Gemini API를 사용하여 최대 6개의 관련 태그를 생성해야 함
3. 생성된 태그는 데이터베이스(note_tags 테이블)에 저장되어야 함
4. 태그는 소문자로 정규화되어 저장되어야 함
5. 중복 태그는 자동으로 제거되어야 함
6. 노트 상세 페이지에서 생성된 태그를 확인할 수 있어야 함
7. 태그 생성 중 로딩 상태를 표시해야 함
8. 태그 생성 실패 시 적절한 에러 메시지를 표시해야 함
9. 토큰 제한(8k)을 초과하는 노트 내용은 자동으로 잘라야 함
10. 이미 태그가 존재하는 노트는 기존 태그를 유지하면서 추가할 수 있어야 함

## Tasks / Subtasks
- [x] Task 1: Note Tags 테이블 스키마 추가 (AC: 3)
  - [x] `drizzle/schema.ts`에 note_tags 테이블 정의
  - [x] note_id (FK), tag 필드 추가
  - [x] 복합 unique 제약 조건 (note_id, tag)
  - [x] 인덱스 추가 (note_id, tag)
  - [x] 타입 추출 (NoteTag, NewNoteTag)
  - [x] 마이그레이션 생성 및 적용

- [x] Task 2: 태그 생성 프롬프트 함수 구현 (AC: 2, 4, 5)
  - [x] `/lib/ai/prompts.ts`에 `generateTagsPrompt` 추가
  - [x] 최대 6개 태그 생성 지시
  - [x] 한 단어 태그 형식 지정
  - [x] 쉼표로 구분된 형식 요청
  - [x] 태그 정규화 함수 (`normalizeTag`) 추가

- [x] Task 3: 태그 생성 Server Action 구현 (AC: 1, 2, 3, 4, 5, 9)
  - [x] `/app/actions/ai.ts`에 `generateNoteTags` 추가
  - [x] 노트 내용 토큰 제한 확인 및 자르기
  - [x] Gemini API 호출하여 태그 생성
  - [x] 태그 파싱 및 정규화
  - [x] 중복 제거 및 최대 6개 제한
  - [x] note_tags 테이블에 저장
  - [x] 사용자 인증 및 권한 확인

- [x] Task 4: 태그 조회 함수 구현 (AC: 10)
  - [x] `/app/actions/ai.ts`에 `getNoteTags` 추가
  - [x] note_id로 태그 목록 조회
  - [x] 사용자 권한 확인
  - [x] 태그 배열 반환

- [x] Task 5: 태그 삭제 함수 구현 (AC: 10)
  - [x] `/app/actions/ai.ts`에 `deleteNoteTag` 추가
  - [x] 특정 태그 삭제 기능
  - [x] 사용자 권한 확인

- [x] Task 6: 노트 상세 페이지에 태그 표시 (AC: 6, 7, 8)
  - [x] `/app/notes/[id]/page.tsx` 수정
  - [x] 태그 섹션 추가
  - [x] "태그 생성" 버튼 추가
  - [x] 로딩 스피너 표시
  - [x] 에러 메시지 표시 UI
  - [x] 태그 뱃지 형태로 표시
  - [x] 태그 삭제 버튼 (X)

- [x] Task 7: 태그 자동 생성 옵션 추가 (AC: 1, 10)
  - [x] 노트 저장 시 "자동 태그 생성" 체크박스 추가
  - [x] 체크박스 상태에 따라 태그 생성 트리거
  - [x] localStorage에 사용자 설정 저장

- [x] Task 8: 테스트 작성
  - [x] 태그 프롬프트 함수 테스트
  - [x] 태그 정규화 함수 테스트
  - [x] Server Action 테스트 (모킹)
  - [x] 중복 제거 테스트
  - [x] UI 통합 테스트

## Dev Notes

### 기술 스택
[Source: docs/architecture.md#1]
- **AI 모델:** Google Gemini API (gemini-2.0-flash)
- **프레임워크:** Next.js App Router (Server Actions)
- **DB:** Supabase Postgres + Drizzle ORM
- **UI:** shadcn/ui + Tailwind CSS

### 데이터 모델
[Source: docs/architecture.md#2]

**Note Tags 테이블:**
```typescript
export const noteTags = pgTable(
  'note_tags',
  {
    id: uuid('id').primaryKey().default(sql`gen_random_uuid()`),
    noteId: uuid('note_id').notNull().references(() => notes.id, { onDelete: 'cascade' }),
    tag: text('tag').notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).notNull().default(sql`now()`)
  },
  (table) => ({
    noteIdIdx: index('note_tags_note_id_idx').on(table.noteId),
    tagIdx: index('note_tags_tag_idx').on(table.tag),
    uniqueNoteTag: unique('unique_note_tag').on(table.noteId, table.tag)
  })
);

export type NoteTag = typeof noteTags.$inferSelect;
export type NewNoteTag = typeof noteTags.$inferInsert;
```

### 보안 규칙
[Source: docs/architecture.md#3]
- Note Tags: 사용자 스코프 (note.user_id를 통한 간접 권한 확인)
- 생성/삭제는 서버 액션에서만 처리

### 태그 생성 프롬프트
[Source: docs/prd.md#3, docs/epics/epic-4#목표]

```typescript
// lib/ai/prompts.ts
export function generateTagsPrompt(content: string): string {
  return `다음 노트 내용에 가장 관련성 높은 태그를 최대 6개까지 생성해주세요.

요구사항:
- 각 태그는 한 단어 또는 짧은 구문이어야 합니다
- 태그는 쉼표로 구분해주세요
- 반드시 한글로 작성해주세요
- 핵심 주제나 키워드를 중심으로 생성해주세요
- 너무 일반적인 태그는 피해주세요

노트 내용:
${content}

태그 (쉼표로 구분):`;
}

export function normalizeTag(tag: string): string {
  return tag
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-') // 공백을 하이픈으로
    .replace(/[^\w가-힣-]/g, ''); // 특수문자 제거
}

export function parseTags(tagsString: string): string[] {
  return tagsString
    .split(',')
    .map(tag => normalizeTag(tag))
    .filter(tag => tag.length > 0 && tag.length <= 20)
    .slice(0, 6); // 최대 6개
}
```

### Server Action 구현
[Source: Story 4.1, Story 4.2 참고]

```typescript
// app/actions/ai.ts
export async function generateNoteTags(noteId: string) {
  const supabase = await createClient();
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    return { success: false, error: 'Unauthorized' };
  }

  try {
    // 노트 조회 및 권한 확인
    const note = await db.query.notes.findFirst({
      where: (notes, { eq, and, isNull }) => 
        and(eq(notes.id, noteId), eq(notes.userId, user.id), isNull(notes.deletedAt))
    });

    if (!note) {
      return { success: false, error: 'Note not found' };
    }

    // 토큰 제한 확인 및 자르기
    const truncatedContent = truncateToTokenLimit(note.content, 7000);

    // 태그 프롬프트 생성
    const prompt = generateTagsPrompt(truncatedContent);

    // Gemini API 호출
    const tagsString = await callGeminiAPI(prompt);

    // 태그 파싱 및 정규화
    const tags = parseTags(tagsString);

    if (tags.length === 0) {
      return { success: false, error: '태그를 생성할 수 없습니다' };
    }

    // 기존 태그 삭제 (선택적)
    await db.delete(noteTags).where(eq(noteTags.noteId, noteId));

    // 새 태그 저장
    const savedTags = await db.insert(noteTags).values(
      tags.map(tag => ({ noteId: note.id, tag }))
    ).returning();

    return { success: true, tags: savedTags };
  } catch (error) {
    const err = error as Error;
    return { success: false, error: err.message };
  }
}

export async function getNoteTags(noteId: string) {
  const supabase = await createClient();
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    return { success: false, error: 'Unauthorized' };
  }

  try {
    // 권한 확인
    const note = await db.query.notes.findFirst({
      where: (notes, { eq, and, isNull }) => 
        and(eq(notes.id, noteId), eq(notes.userId, user.id), isNull(notes.deletedAt))
    });

    if (!note) {
      return { success: false, error: 'Note not found' };
    }

    // 태그 조회
    const tags = await db.query.noteTags.findMany({
      where: (noteTags, { eq }) => eq(noteTags.noteId, noteId),
      orderBy: (noteTags, { asc }) => [asc(noteTags.createdAt)]
    });

    return { success: true, tags };
  } catch (error) {
    const err = error as Error;
    return { success: false, error: err.message };
  }
}

export async function deleteNoteTag(noteId: string, tag: string) {
  const supabase = await createClient();
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    return { success: false, error: 'Unauthorized' };
  }

  try {
    // 권한 확인
    const note = await db.query.notes.findFirst({
      where: (notes, { eq, and, isNull }) => 
        and(eq(notes.id, noteId), eq(notes.userId, user.id), isNull(notes.deletedAt))
    });

    if (!note) {
      return { success: false, error: 'Note not found' };
    }

    // 태그 삭제
    await db.delete(noteTags).where(
      and(eq(noteTags.noteId, noteId), eq(noteTags.tag, tag))
    );

    return { success: true };
  } catch (error) {
    const err = error as Error;
    return { success: false, error: err.message };
  }
}
```

### UI 구현 예시
[Source: project-rule.mdc - UI 원칙]

```tsx
// app/notes/[id]/page.tsx (일부)
const [tags, setTags] = useState<string[]>([]);
const [isGenerating, setIsGenerating] = useState(false);
const [error, setError] = useState<string | null>(null);

// 태그 로드
useEffect(() => {
  async function loadTags() {
    const result = await getNoteTags(noteId);
    if (result.success && result.tags) {
      setTags(result.tags.map(t => t.tag));
    }
  }
  loadTags();
}, [noteId]);

// 태그 생성 핸들러
async function handleGenerateTags() {
  setIsGenerating(true);
  setError(null);
  
  const result = await generateNoteTags(noteId);
  
  if (result.success && result.tags) {
    setTags(result.tags.map(t => t.tag));
    toast.success('태그가 생성되었습니다');
  } else {
    setError(result.error || '태그 생성 실패');
    toast.error('태그 생성에 실패했습니다');
  }
  
  setIsGenerating(false);
}

// 태그 삭제 핸들러
async function handleDeleteTag(tag: string) {
  const result = await deleteNoteTag(noteId, tag);
  if (result.success) {
    setTags(tags.filter(t => t !== tag));
    toast.success('태그가 삭제되었습니다');
  } else {
    toast.error('태그 삭제에 실패했습니다');
  }
}

// UI 렌더링
<div className="mt-6">
  <div className="flex items-center justify-between mb-3">
    <h3 className="font-semibold text-gray-900">태그</h3>
    <Button
      onClick={handleGenerateTags}
      disabled={isGenerating}
      size="sm"
      variant="outline"
    >
      {isGenerating ? '생성 중...' : '자동 생성'}
    </Button>
  </div>
  
  {isGenerating && <Spinner />}
  
  {error && (
    <p className="text-sm text-red-600 mb-2">{error}</p>
  )}
  
  <div className="flex flex-wrap gap-2">
    {tags.map((tag) => (
      <div
        key={tag}
        className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
      >
        <span>{tag}</span>
        <button
          onClick={() => handleDeleteTag(tag)}
          className="hover:text-blue-600"
          aria-label="태그 삭제"
        >
          ×
        </button>
      </div>
    ))}
    
    {tags.length === 0 && !isGenerating && (
      <p className="text-sm text-gray-500">
        태그를 자동 생성하려면 버튼을 클릭하세요
      </p>
    )}
  </div>
</div>
```

### 프로젝트 구조
```
/drizzle/schema.ts            # note_tags 테이블 추가
/lib/ai/prompts.ts            # generateTagsPrompt, normalizeTag, parseTags 추가
/app/actions/ai.ts            # generateNoteTags, getNoteTags, deleteNoteTag 추가
/app/notes/[id]/page.tsx      # 태그 표시 UI 추가

/__tests__/lib/ai/prompts.test.ts (태그 함수 테스트 추가)
/__tests__/app/actions/ai.test.ts (추가 테스트)
```

### 주의사항
[Source: project-rule.mdc]
- 모든 파일은 4줄의 헤더 주석으로 시작
- 파일은 500 LOC 이하 유지
- 태그는 소문자로 정규화하여 일관성 유지
- 중복 태그 방지를 위해 unique 제약 조건 사용

### 태그 정규화 규칙
- 앞뒤 공백 제거
- 소문자 변환
- 단어 간 공백은 하이픈(-)으로 변환
- 특수문자 제거 (한글, 영문, 숫자, 하이픈만 허용)
- 최대 길이 20자 제한

### 의존성
[Source: Story 4.1]
- Story 4.1 (Gemini API 설정 및 연동) 완료 필수
- `lib/ai/gemini-api.ts`의 `callGeminiAPI` 함수 사용
- `lib/ai/token-counter.ts`의 `truncateToTokenLimit` 함수 사용

### 성능 고려사항
[Source: docs/epics/epic-4#성공지표]
- AI 처리 시간 10초 이내 목표
- 태그 캐싱 (이미 생성된 태그 재사용 가능)
- 태그 관련성 85% 이상 목표

### Testing

#### 테스트 파일 위치
- 프롬프트 및 유틸 함수 테스트: `__tests__/lib/ai/prompts.test.ts`
- Server Action 테스트: `__tests__/app/actions/ai.test.ts` (기존 파일에 추가)

#### 테스트 표준
[Source: project-rule.mdc]
- 테스트 실행: `pnpm test`
- 모든 기능은 단위 테스트 필수

#### 이 스토리의 테스트 요구사항
1. **프롬프트 함수 테스트:**
   - 프롬프트 형식 확인
   - 노트 내용 포함 확인

2. **태그 정규화 테스트:**
   - 공백 제거 확인
   - 소문자 변환 확인
   - 특수문자 제거 확인
   - 길이 제한 확인

3. **태그 파싱 테스트:**
   - 쉼표 구분 파싱 확인
   - 중복 제거 확인
   - 최대 6개 제한 확인

4. **Server Action 테스트:**
   - 인증 확인 테스트
   - 노트 권한 확인 테스트
   - 태그 생성 및 저장 테스트
   - 태그 조회 테스트
   - 태그 삭제 테스트
   - 에러 핸들링 테스트

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 스토리 초안 생성 | SM-Bob |
| 2025-10-14 | 1.1 | AI 모델을 gemini-2.0-flash로 변경 | SM-Bob |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (2025-01-14)

### Debug Log References
- 마이그레이션 생성: `drizzle/migrations/0004_abnormal_miek.sql`
- 태그 관련 테스트 통과 확인

### Completion Notes List
- ✅ note_tags 테이블 스키마 추가 및 마이그레이션 생성 완료
- ✅ 태그 생성 프롬프트 함수 구현 (최대 6개, 한글 태그)
- ✅ 태그 정규화 및 파싱 함수 구현
- ✅ Server Action 3개 함수 구현 (생성, 조회, 삭제)
- ✅ 노트 상세 페이지에 태그 UI 컴포넌트 추가
- ✅ 노트 생성 페이지에 자동 태그 생성 옵션 추가
- ✅ 체크박스 UI 컴포넌트 추가
- ✅ 포괄적인 테스트 작성 (프롬프트, 정규화, Server Action)

### File List
**새로 생성된 파일:**
- `components/ui/checkbox.tsx` - 체크박스 UI 컴포넌트
- `components/notes/note-tags.tsx` - 태그 표시 및 관리 컴포넌트
- `drizzle/migrations/0004_abnormal_miek.sql` - note_tags 테이블 마이그레이션

**수정된 파일:**
- `drizzle/schema.ts` - note_tags 테이블 스키마 추가
- `lib/ai/prompts.ts` - 태그 생성 프롬프트 및 정규화 함수 추가
- `app/actions/ai.ts` - 태그 관련 Server Action 3개 함수 추가
- `app/actions/notes.ts` - 자동 태그 생성 기능 추가
- `app/notes/[id]/page.tsx` - 태그 컴포넌트 통합
- `app/notes/new/page.tsx` - 자동 태그 생성 체크박스 추가
- `__tests__/lib/ai/prompts.test.ts` - 태그 관련 함수 테스트 추가
- `__tests__/app/actions/ai.test.ts` - 태그 Server Action 테스트 추가

---

<!-- Powered by BMAD™ Core -->

